[INF] 0a 06 08 00 10 00 18 00 10 dd 20 
[INF] name: /MRBTS-1/EQM-1/SMOD-4113/CCU-1/CPU-3

[INF] 0a 08 08 00 10 01 18 00 20 01 12 05 08 dd 20 18 00 
[INF] name: /MRBTS-1/EQM-1/SMOD-4113/CCU-1/CPU-3/SYNC-1

[INF] 0a 08 08 01 10 01 18 00 20 01 12 0f 12 0d 41 73 69 61 2f 53 68 61 6e 67 68 61 69 18 01 50 02 68 12 79 00 00 00 00 00 00 00 00 90 01 01 a0 01 00 c0 01 00 
[INF] name: /MRBTS-1/EQM-1/SMOD-4113/TIME-1

[INF] 0a 06 08 00 10 00 18 00 10 91 20 
[INF] name: /MRBTS-1/EQM-1/SMOD-4113/CCU-1/CPU-1

[INF] name: /MRBTS-1/EQM-1/SMOD-4113/CLOCK-1
[INF] 0a 0a 08 01 10 01 18 00 20 01 28 00 12 06 08 00 10 01 18 01 12 06 08 06 10 01 18 01 12 06 08 07 10 01 18 01 1a 04 08 00 10 02 1a 04 08 06 10 00 1a 04 08 07 10 00 20 00 50 00 82 01 2b 2f 4d 52 42 54 53 2d 31 2f 45 51 4d 2d 31 2f 53 4d 4f 44 2d 34 31 31 33 2f 43 43 55 2d 31 2f 4f 53 43 49 4c 4c 41 54 4f 52 2d 31 a8 01 00 

[INF] name: /MRBTS-1/RAT-1/BTS_L-1/EQM_L-1/RMOD_L-2/RU_L-1/TX_PU_L-8/TX_PU_BP_L-1
[INF] 08 00 10 00 19 00 00 00 00 00 00 00 00 21 00 00 00 00 00 00 00 00 2a 04 54 78 47 38 30 02 41 00 00 00 00 d8 f8 15 41 49 00 00 00 00 80 c0 14 41 52 21 31 30 2c 31 35 2c 32 30 2c 33 30 2c 34 30 2c 35 30 2c 36 30 2c 37 30 2c 38 30 2c 39 30 2c 31 30 30 59 00 00 00 00 00 00 59 40 59 00 00 00 00 00 00 69 40 59 00 00 00 00 00 c0 72 40 59 00 00 00 00 00 00 79 40 59 00 00 00 00 00 40 7f 40 59 00 00 00 00 00 c0 82 40 59 00 00 00 00 00 e0 85 40 59 00 00 00 00 00 00 89 40 59 00 00 00 00 00 20 8c 40 59 00 00 00 00 00 40 8f 40 72 60 08 05 12 5c 08 4e 11 00 00 00 00 00 00 59 40 11 00 00 00 00 00 00 69 40 11 00 00 00 00 00 c0 72 40 11 00 00 00 00 00 00 79 40 11 00 00 00 00 00 40 7f 40 11 00 00 00 00 00 c0 82 40 11 00 00 00 00 00 e0 85 40 11 00 00 00 00 00 00 89 40 11 00 00 00 00 00 20 8c 40 11 00 00 00 00 00 40 8f 40 72 21 08 00 12 1d 08 2a 11 00 00 00 00 00 00 59 40 11 00 00 00 00 00 c0 62 40 11 00 00 00 00 00 00 69 40 7a 29 08 90 4e 08 a0 9c 01 08 b0 ea 01 08 c0 b8 02 08 d0 86 03 08 e0 d4 03 08 f0 a2 04 08 80 f1 04 08 90 bf 05 08 a0 8d 06 10 05 7a 0c 08 90 4e 08 98 75 08 a0 9c 01 10 00 80 01 04 90 01 03 98 01 00 a9 01 00 00 00 00 00 88 e3 40 b9 01 00 00 00 00 00 f9 15 41 b9 01 00 00 00 00 80 13 1c 41 c9 01 00 00 00 00 00 00 f0 3f d1 01 00 00 00 00 00 88 d3 40 d9 01 00 00 00 00 00 88 d3 40 e2 01 0f 08 04 12 0b 08 4e 11 00 00 00 00 00 40 9f 40 e2 01 0f 08 00 12 0b 08 2a 11 00 00 00 00 00 40 9f 40 ea 01 18 08 03 12 14 08 4e 11 00 00 00 00 00 9a e0 40 19 00 00 00 00 e0 93 e1 40 ea 01 18 08 00 12 14 08 2a 11 00 00 00 00 00 9a e0 40 19 00 00 00 00 e0 93 e1 40 80 02 01 b0 02 00 b9 02 00 00 00 00 00 00 00 00 c0 02 00 d9 02 00 00 00 00 00 00 00 00 

struct Field
{
    pair string, Field[]; // name - array of Fields
    FieldType ft; // simple or repeated
}

struct Object
{
    string path;
    vector Field fields;
}

-- Object
  -- fName (list)
    -- [0] 
      -- fName (list)
        -- [0]
          -- fName : val
          -- fName : val

// needs meta to be available
1: {
  1: some_val
  2: {
    4: other_val
  }
}

we are on /SMTH-1/CEVA-1/ALARM_RECORD-1
=> get end class name: ALARM_RECORD
=> find it in BM meta xml node and store it
=> pb decodes field number "2"
=> look through ALARM_RECORD xml nodes and find "p" node which has child "proto" with
   attrib named "index" who's value is "2"
=> the name of the changed field will be p.name attrib. Other "p" and child "proto" attribs
   will tell more about the changed field (is enum/repeated/type etc)
=> from this, construct a Field object


if repeated
  if integer || boolean || double
    =>  decodePayload(objectNode,
else